/*
 * qtcdbg Copyright (C) 2019-2020 Frogtoss Games, Inc.
 */

package main

import (
	"fmt"
	"io/ioutil"
	"os"
	"path/filepath"
	"strings"
	"text/template"
)

func getProjectRoot(cfg *TomlConfig) string {
	cfgDir, _ := filepath.Split(cfg.Misc.cfgPath)
	projectRoot := filepath.Join(cfgDir, cfg.Project.RelativeRoot)
	projectRoot = filepath.Clean(projectRoot)
	projectRoot, _ = filepath.Abs(projectRoot)

	if *debug {
		fmt.Printf("Project root: %s\ncfgDir: %s\n", projectRoot, cfgDir)
	}

	return projectRoot
}

func getGeneratorPath(cfg *TomlConfig, filename string) string {
	cfgDir, _ := filepath.Split(cfg.Misc.cfgPath)
	return filepath.Join(cfgDir, filename)
}

func createFile(cfg *TomlConfig, suffix string) (*os.File, error) {
	filename := cfg.Project.Name + suffix
	return os.Create(getGeneratorPath(cfg, filename))
}

func GenerateCflags(cfg *TomlConfig) error {
	f, err := createFile(cfg, ".cflags")
	if err != nil {
		return err
	}
	defer f.Close()

	// it's empty, so just return

	return nil
}

func GenerateConfig(cfg *TomlConfig) error {
	f, err := createFile(cfg, ".config")
	if err != nil {
		return err
	}
	defer f.Close()

	body := "// generated by qtcdbg\n"
	for _, def := range cfg.Generate.ConfigDefines {
		body += fmt.Sprintf("#define %s\n", def)
	}

	f.WriteString(body)

	return nil
}

func GenerateCreator(cfg *TomlConfig) error {
	f, err := createFile(cfg, ".creator")
	if err != nil {
		return err
	}
	defer f.Close()

	body := "[General]\n"
	f.WriteString(body)

	return nil
}

func GenerateCxxFlags(cfg *TomlConfig) error {
	f, err := createFile(cfg, ".cxxflags")
	if err != nil {
		return err
	}
	defer f.Close()

	// empty file

	return nil
}

func GenerateFiles(cfg *TomlConfig) error {
	f, err := createFile(cfg, ".files")
	if err != nil {
		return err
	}
	defer f.Close()

	projectRoot := getProjectRoot(cfg)
	// push/pop the path to ensure generate paths do not include
	// the full directory structure
	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	defer os.Chdir(cwd)
	os.Chdir(projectRoot)

	// just add almost all files under the project root.  because this
	// qtc project will be used for debugging only, it is a low
	// priority to cull this perfectly.
	err = filepath.Walk(".",
		func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}

			// handles .git, etc
			if strings.HasPrefix(path, ".") {
				return nil
			}

			if info.IsDir() {
				return nil
			}

			relativePath := filepath.Join(cfg.Project.RelativeRoot, path)
			f.WriteString(relativePath + "\n")

			return nil
		})
	if err != nil {
		return err
	}

	return err
}

func GenerateIncludes(cfg *TomlConfig) error {
	f, err := createFile(cfg, ".includes")
	if err != nil {
		return err
	}
	defer f.Close()

	projectRoot := getProjectRoot(cfg)

	cwd, err := os.Getwd()
	if err != nil {
		return err
	}
	defer os.Chdir(cwd)
	os.Chdir(projectRoot)

	// headerFilesDirs contains all paths with header files in them.
	// as with GenerateFiles above, this is a blunt way of going about
	// it, but since it is just used for header search paths for a
	// quick debug session, it is better to just be inclusive here.

	//headerFilesDirs := make([]string, 10)
	headerFilesDirs := make(map[string]int)
	err = filepath.Walk(".",
		func(path string, info os.FileInfo, err error) error {
			if err != nil {
				return err
			}

			if !info.IsDir() {
				return nil
			}

			allFiles, err := ioutil.ReadDir(path)
			if err != nil {
				return err
			}
			for _, file := range allFiles {
				if filepath.Ext(file.Name()) == ".h" {
					headerFilesDirs[path] = 1
				}
			}

			return nil
		})

	for _, additionalPath := range cfg.Generate.AdditionalIncludeSearchDirs {
		headerFilesDirs[additionalPath] = 1
	}

	for path, _ := range headerFilesDirs {
		relativePath := filepath.Join(cfg.Project.RelativeRoot, path)
		f.WriteString(relativePath + "\n")
	}

	return nil
}

func GenerateCreatorUser(cfg *TomlConfig) error {
	f, err := createFile(cfg, ".creator.user")
	if err != nil {
		return err
	}
	defer f.Close()

	tmpl, err := template.New("creator").Parse(*tmplCreator)
	if err != nil {
		return nil
	}

	err = tmpl.Execute(f, cfg)

	return err
}

func CleanupGeneratedFiles(cfg *TomlConfig, skip bool) {
	cfgDir, _ := filepath.Split(cfg.Misc.cfgPath)
	
	if skip {
		fmt.Printf("Skipping cleanup of generated files.\n")
		return
	}
	extensions := []string{".cflags",
		".config",
		".creator",
		".cxxflags",
		".files",
		".includes",
		".creator.user",
	};

	for _, ext := range extensions {
		filename := cfg.Project.Name + ext

		path := filepath.Join(cfgDir, filename)
			
		os.Remove(path)
	}
}
